did_kernel_6 <- match_did_kernel_estimator(6, df)
did_kernel_4
did_kernel_5
did_kernel_6
h = 2.345*nrow(df_itemd)^(-1/5)*sd(df_itemd$p)
match_did_kernel_estimator = function(timeframe, data) {
post_vec = 1:timeframe
pre_vec = -post_vec
valid_indexes_post = data %>% filter(qtr %in% post_vec) %>%
select(id) %>% unique()
valid_indexes_pre = data %>% filter(qtr %in% pre_vec) %>%
select(id) %>% unique()
valid_indexes = intersect(valid_indexes_post, valid_indexes_pre) %>% unlist()
df_itemd = data %>% filter(id %in% valid_indexes) %>%
filter(qtr>= -timeframe) %>% filter(qtr <= timeframe) %>%
mutate(post = ifelse(qtr > 0, "post", "pre")) %>%
group_by(post, id) %>%
mutate(mean = mean(earn)) %>% slice(1) %>%
ungroup() %>%
select(id, d, mean, p, post) %>%
pivot_wider(names_from = post, values_from = mean) %>%
mutate(diff_in_means = post-pre) %>%
select(-c(post, pre))
score_control = df_itemd[df_itemd$d == 0, ]   # i generate which is which to get the
score_treatment =  df_itemd[df_itemd$d == 1, ]  #
combinations = expand.grid(score_treatment$p, score_control$p)
h = 2.345*nrow(df_itemd)^(-1/5)*sd(df_itemd$p)
Kern_mat = matrix(epanechnikov((combinations[, 2] - combinations[, 1])/h), nrow = nrow(score_treatment))
W_mat = apply(Kern_mat, 2, function(i) i/sum(i))
alpha = colMeans(score_treatment$diff_in_means - W_mat %*% score_control$diff_in_means)
return(alpha, h)
}
match_did_kernel_estimator = function(timeframe, data) {
post_vec = 1:timeframe
pre_vec = -post_vec
valid_indexes_post = data %>% filter(qtr %in% post_vec) %>%
select(id) %>% unique()
valid_indexes_pre = data %>% filter(qtr %in% pre_vec) %>%
select(id) %>% unique()
valid_indexes = intersect(valid_indexes_post, valid_indexes_pre) %>% unlist()
df_itemd = data %>% filter(id %in% valid_indexes) %>%
filter(qtr>= -timeframe) %>% filter(qtr <= timeframe) %>%
mutate(post = ifelse(qtr > 0, "post", "pre")) %>%
group_by(post, id) %>%
mutate(mean = mean(earn)) %>% slice(1) %>%
ungroup() %>%
select(id, d, mean, p, post) %>%
pivot_wider(names_from = post, values_from = mean) %>%
mutate(diff_in_means = post-pre) %>%
select(-c(post, pre))
score_control = df_itemd[df_itemd$d == 0, ]   # i generate which is which to get the
score_treatment =  df_itemd[df_itemd$d == 1, ]  #
combinations = expand.grid(score_treatment$p, score_control$p)
h = 2.345*nrow(df_itemd)^(-1/5)*sd(df_itemd$p)
Kern_mat = matrix(epanechnikov((combinations[, 2] - combinations[, 1])/h), nrow = nrow(score_treatment))
W_mat = apply(Kern_mat, 2, function(i) i/sum(i))
alpha = colMeans(score_treatment$diff_in_means - W_mat %*% score_control$diff_in_means)
return(alpha, h, nrows(df_itemd))
}
match_did_kernel_estimator(4, df)
return(c(alpha, h, nrows(df_itemd)))
match_did_kernel_estimator = function(timeframe, data) {
post_vec = 1:timeframe
pre_vec = -post_vec
valid_indexes_post = data %>% filter(qtr %in% post_vec) %>%
select(id) %>% unique()
valid_indexes_pre = data %>% filter(qtr %in% pre_vec) %>%
select(id) %>% unique()
valid_indexes = intersect(valid_indexes_post, valid_indexes_pre) %>% unlist()
df_itemd = data %>% filter(id %in% valid_indexes) %>%
filter(qtr>= -timeframe) %>% filter(qtr <= timeframe) %>%
mutate(post = ifelse(qtr > 0, "post", "pre")) %>%
group_by(post, id) %>%
mutate(mean = mean(earn)) %>% slice(1) %>%
ungroup() %>%
select(id, d, mean, p, post) %>%
pivot_wider(names_from = post, values_from = mean) %>%
mutate(diff_in_means = post-pre) %>%
select(-c(post, pre))
score_control = df_itemd[df_itemd$d == 0, ]   # i generate which is which to get the
score_treatment =  df_itemd[df_itemd$d == 1, ]  #
combinations = expand.grid(score_treatment$p, score_control$p)
h = 2.345*nrow(df_itemd)^(-1/5)*sd(df_itemd$p)
Kern_mat = matrix(epanechnikov((combinations[, 2] - combinations[, 1])/h), nrow = nrow(score_treatment))
W_mat = apply(Kern_mat, 2, function(i) i/sum(i))
alpha = colMeans(score_treatment$diff_in_means - W_mat %*% score_control$diff_in_means)
return(c(alpha, h, nrows(df_itemd)))
}
match_did_kernel_estimator(4, df)
match_did_kernel_estimator = function(timeframe, data) {
post_vec = 1:timeframe
pre_vec = -post_vec
valid_indexes_post = data %>% filter(qtr %in% post_vec) %>%
select(id) %>% unique()
valid_indexes_pre = data %>% filter(qtr %in% pre_vec) %>%
select(id) %>% unique()
valid_indexes = intersect(valid_indexes_post, valid_indexes_pre) %>% unlist()
df_itemd = data %>% filter(id %in% valid_indexes) %>%
filter(qtr>= -timeframe) %>% filter(qtr <= timeframe) %>%
mutate(post = ifelse(qtr > 0, "post", "pre")) %>%
group_by(post, id) %>%
mutate(mean = mean(earn)) %>% slice(1) %>%
ungroup() %>%
select(id, d, mean, p, post) %>%
pivot_wider(names_from = post, values_from = mean) %>%
mutate(diff_in_means = post-pre) %>%
select(-c(post, pre))
score_control = df_itemd[df_itemd$d == 0, ]   # i generate which is which to get the
score_treatment =  df_itemd[df_itemd$d == 1, ]  #
combinations = expand.grid(score_treatment$p, score_control$p)
h = 2.345*nrow(df_itemd)^(-1/5)*sd(df_itemd$p)
Kern_mat = matrix(epanechnikov((combinations[, 2] - combinations[, 1])/h), nrow = nrow(score_treatment))
W_mat = apply(Kern_mat, 2, function(i) i/sum(i))
alpha = colMeans(score_treatment$diff_in_means - W_mat %*% score_control$diff_in_means)
return(c(alpha, h, nrow(df_itemd)))
}
match_did_kernel_estimator(4, df)
df_itemd = data %>% filter(id %in% valid_indexes) %>%
filter(qtr>= -4) %>% filter(qtr <= 4) %>%
mutate(post = ifelse(qtr > 0, "post", "pre")) %>%
group_by(post, id) %>%
mutate(mean = mean(earn)) %>% slice(1) %>%
ungroup() %>%
select(id, d, mean, p, post) %>%
pivot_wider(names_from = post, values_from = mean) %>%
mutate(diff_in_means = post-pre) %>%
select(-c(post, pre))
match_did_kernel_estimator(5, df)
match_did_kernel_estimator(6, df)
# Importing useful packages:
library(tidyverse)
library(ggplot2)
library(RANN)
library(dotwhisker)
library(stargazer)
# Importing data:
setwd(this.path::here())
df = read_csv("jtpa_ps2.csv")
y_of_treated_after_treatment_4 = colMeans(df[df$d == 1 & df$qtr > 0 & abs(df$qtr) <= 4, 'earn'])
y_of_treated_before_treatment_4 = colMeans(df[df$d == 1 & df$qtr < 0 & abs(df$qtr) <= 4, 'earn'])
y_of_control_after_treatment_4 = colMeans(df[df$d == 0 & df$qtr > 0 & abs(df$qtr) <= 4, 'earn'])
y_of_control_before_treatment_4 = colMeans(df[df$d == 0 & df$qtr < 0 & abs(df$qtr) <= 4, 'earn'])
y_of_treated_after_treatment_5 = colMeans(df[df$d == 1 & df$qtr > 0 & abs(df$qtr) <= 5, 'earn'])
y_of_treated_before_treatment_5 = colMeans(df[df$d == 1 & df$qtr < 0 & abs(df$qtr) <= 5, 'earn'])
y_of_control_after_treatment_5 = colMeans(df[df$d == 0 & df$qtr > 0 & abs(df$qtr) <= 5, 'earn'])
y_of_control_before_treatment_5 = colMeans(df[df$d == 0 & df$qtr < 0 & abs(df$qtr) <= 5, 'earn'])
y_of_treated_after_treatment_6 = colMeans(df[df$d == 1 & df$qtr > 0 & abs(df$qtr) <= 6, 'earn'])
y_of_treated_before_treatment_6 = colMeans(df[df$d == 1 & df$qtr < 0 & abs(df$qtr) <= 6, 'earn'])
y_of_control_after_treatment_6 = colMeans(df[df$d == 0 & df$qtr > 0 & abs(df$qtr) <= 6, 'earn'])
y_of_control_before_treatment_6 = colMeans(df[df$d == 0 & df$qtr < 0 & abs(df$qtr) <= 6, 'earn'])
did_estimator = function(timeframe) {
y_of_treated_after_treatment = colMeans(df[df$d == 1 & df$qtr > 0 & abs(df$qtr) <= timeframe, 'earn'])
y_of_treated_before_treatment = colMeans(df[df$d == 1 & df$qtr < 0 & abs(df$qtr) <= timeframe, 'earn'])
y_of_control_after_treatment = colMeans(df[df$d == 0 & df$qtr > 0 & abs(df$qtr) <= timeframe, 'earn'])
y_of_control_before_treatment = colMeans(df[df$d == 0 & df$qtr < 0 & abs(df$qtr) <= timeframe, 'earn'])
alpha = (y_of_treated_after_treatment - y_of_treated_before_treatment) -
(y_of_control_after_treatment - y_of_control_before_treatment)
return(alpha)
}
did_4 <- did_estimator(4)
did_5 <- did_estimator(5)
did_6 <- did_estimator(6)
did_4
did_5
did_6
df_itemb = df %>%
mutate(post = ifelse(qtr>0, 1, 0))
reg_itemb_calculator = function(timeframe) {
lm(earn ~ d + post + post*d, data = df_itemb[abs(df_itemb$qtr) <= timeframe, ])
}
summary(reg_itemb_calculator(4))
summary(reg_itemb_calculator(5))
summary(reg_itemb_calculator(6))
# Generating LaTeX table with all the results.
stargazer(reg_itemb_calculator(4), reg_itemb_calculator(5), reg_itemb_calculator(6), no.space=TRUE, digits=2)
df_itemc = df %>%
group_by(d, qtr) %>%
summarise(mean = mean(earn)) %>%
mutate(post = ifelse(qtr>0, 1, 0))
ggplot(df_itemc, aes(x = qtr, y = mean, color = as.factor(d) )) + geom_line(linetype = 'dashed') +
geom_line(data = df_itemc[df_itemc$qtr <= -1, ], aes(x = qtr, y = mean, color =
as.factor(d)), size = 1.1) +
geom_line(data = df_itemc[df_itemc$qtr >= 1, ], aes(x = qtr, y = mean, color =
as.factor(d)), size = 1.1) +
labs(color = 'Treatment Status') +
geom_vline(xintercept = 0, linetype = 'dashed', alpha=0.5) +
annotate(geom = "text", x = -0.3, y = 750, label = "TREATMENT ASSIGNMENT", color = "black", alpha=0.5,
angle = 90) +
theme_bw() + scale_color_brewer(palette="Paired") +
ggtitle("Mean earnings per quarter for treated and non-treated individuals")
match_did_nn_estimator = function(timeframe, data) {
post_vec = 1:timeframe        # Generate the array of necessary observations.
pre_vec = -post_vec
valid_indexes_post = data %>% filter(qtr %in% post_vec) %>%  # Check if this ID has a valid post
select(id) %>% unique()                                    # observation.
valid_indexes_pre = data %>% filter(qtr %in% pre_vec) %>%   # The same, but for before treatment.
select(id) %>% unique()
valid_indexes = intersect(valid_indexes_post, valid_indexes_pre) %>% unlist() # Get IDs with both.
df_itemd = data %>% filter(id %in% valid_indexes) %>%        # Get only correct IDs.
filter(qtr>= -timeframe) %>% filter(qtr <= timeframe) %>%  # Get only relevant obs from them.
mutate(post = ifelse(qtr > 0, "post", "pre")) %>%          # Split data into pre and post treat.
group_by(post, id) %>%
mutate(mean = mean(earn)) %>% slice(1) %>%     # Calculate average per id per pre/post treat,
ungroup() %>%                                    # then convert the df into a table with only
select(id, d, mean, p, post) %>%                 # id, treatment status, and avg before/after treat.
pivot_wider(names_from = post, values_from = mean) %>%
mutate(diff_in_means = post-pre) %>%            # Calculate difference in means for each ind.
select(-c(post, pre))                           # Drop unnecessary variables.
score_control = df_itemd[df_itemd$d == 0, ]   # i generate which is which to get the
score_treatment =  df_itemd[df_itemd$d == 1, ]  # nearest neighbors using RANN
nn_indexes = nn2(score_control$p, score_treatment$p, k = 2)
df_nn = as.data.frame(nn_indexes$nn.idx)
control_diff = (score_control[df_nn$V1, 'diff_in_means'] + score_control[df_nn$V2, 'diff_in_means'])/2
alpha = colMeans(score_treatment$diff_in_means - control_diff)
return(alpha)
}
did_nn_4 <- match_did_nn_estimator(4, df)
did_nn_5 <- match_did_nn_estimator(5, df)
did_nn_6 <- match_did_nn_estimator(6, df)
did_nn_4
did_nn_5
did_nn_6
match_did_nn_graph = function(timeframe, data) {
post_vec = 1:timeframe        # Generate the array of necessary observations.
pre_vec = -post_vec
valid_indexes_post = data %>% filter(qtr %in% post_vec) %>%  # Check if this ID has a valid post
select(id) %>% unique()                                    # observation.
valid_indexes_pre = data %>% filter(qtr %in% pre_vec) %>%   # The same, but for before treatment.
select(id) %>% unique()
valid_indexes = intersect(valid_indexes_post, valid_indexes_pre) %>% unlist() # Get IDs with both.
df_itemd = data %>% filter(id %in% valid_indexes) %>%        # Get only correct IDs.
filter(qtr>= -timeframe) %>% filter(qtr <= timeframe) %>%  # Get only relevant obs from them.
mutate(post = ifelse(qtr > 0, "post", "pre"))
score_control = df_itemd[df_itemd$d == 0, ] # i generate which is which to get the
score_treatment =  df_itemd[df_itemd$d == 1, ]  # nearest neighbors using RANN
nn_indexes = nn2(score_control$p, score_treatment$p, k = 2)
df_nn = as.data.frame(nn_indexes$nn.idx)
df_with_match = tibble(score_treatment, id1 = score_control[df_nn$V1, ]$id,
id2 = score_control[df_nn$V2, ]$id) %>%
left_join(select(score_control, c('id', 'earn', 'qtr')), by = c("id1" = "id", "qtr")) %>%
left_join(select(score_control, c('id', 'earn', 'qtr')), by = c("id2" = "id", "qtr")) %>%
mutate(earn_control = earn.y + earn)
match_control = df_with_match %>% select(id, qtr, earn_control) %>%
mutate(d=0) %>% rename('earn' = earn_control)
graph_df = score_treatment %>% select(id, qtr, d, earn) %>% rbind(match_control) %>%
group_by(qtr, d) %>% summarise(mean = mean(earn, na.rm = T)) %>%
mutate(post = ifelse(qtr>0, 1, 0))
ggplot(graph_df, aes(x = qtr, y = mean, color = as.factor(d) )) + geom_line(linetype = 'dashed') +
geom_line(data = graph_df[graph_df$qtr <= -1, ], aes(x = qtr, y = mean, color =
as.factor(d)), size = 1.1) +
geom_line(data = graph_df[graph_df$qtr >= 1, ], aes(x = qtr, y = mean, color =
as.factor(d)), size = 1.1) +
labs(color = 'Treatment Status') +
geom_vline(xintercept = 0, linetype = 'dashed', alpha=0.5) +
annotate(geom = "text", x = -0.3, y = 750, label = "TREATMENT ASSIGNMENT", color = "black", alpha=0.5,
angle = 90) +
theme_bw() + scale_color_brewer(palette="Paired") +
ggtitle("Mean earnings per quarter for treated and non-treated individuals")
}
match_did_nn_graph(6, df)
match_did_nn_graph = function(timeframe, data) {
post_vec = 1:timeframe        # Generate the array of necessary observations.
pre_vec = -post_vec
valid_indexes_post = data %>% filter(qtr %in% post_vec) %>%  # Check if this ID has a valid post
select(id) %>% unique()                                    # observation.
valid_indexes_pre = data %>% filter(qtr %in% pre_vec) %>%   # The same, but for before treatment.
select(id) %>% unique()
valid_indexes = intersect(valid_indexes_post, valid_indexes_pre) %>% unlist() # Get IDs with both.
df_itemd = data %>% filter(id %in% valid_indexes) %>%        # Get only correct IDs.
filter(qtr>= -timeframe) %>% filter(qtr <= timeframe) %>%  # Get only relevant obs from them.
mutate(post = ifelse(qtr > 0, "post", "pre"))
score_control = df_itemd[df_itemd$d == 0, ] # i generate which is which to get the
score_treatment =  df_itemd[df_itemd$d == 1, ]  # nearest neighbors using RANN
nn_indexes = nn2(score_control$p, score_treatment$p, k = 2)
df_nn = as.data.frame(nn_indexes$nn.idx)
df_with_match = tibble(score_treatment, id1 = score_control[df_nn$V1, ]$id,
id2 = score_control[df_nn$V2, ]$id) %>%
left_join(select(score_control, c('id', 'earn', 'qtr')), by = c("id1" = "id", "qtr")) %>%
left_join(select(score_control, c('id', 'earn', 'qtr')), by = c("id2" = "id", "qtr")) %>%
mutate(earn_control = earn.y + earn)
match_control = df_with_match %>% select(id, qtr, earn_control) %>%
mutate(d=0) %>% rename('earn' = earn_control)
graph_df = score_treatment %>% select(id, qtr, d, earn) %>% rbind(match_control) %>%
group_by(qtr, d) %>% summarise(mean = mean(earn, na.rm = T)) %>%
mutate(post = ifelse(qtr>0, 1, 0))
ggplot(graph_df, aes(x = qtr, y = mean, color = as.factor(d) )) + geom_line(linetype = 'dashed') +
geom_line(data = graph_df[graph_df$qtr <= -1, ], aes(x = qtr, y = mean, color =
as.factor(d)), size = 1.1) +
geom_line(data = graph_df[graph_df$qtr >= 1, ], aes(x = qtr, y = mean, color =
as.factor(d)), size = 1.1) +
labs(color = 'Treatment Status') +
geom_vline(xintercept = 0, linetype = 'dashed', alpha=0.5) +
annotate(geom = "text", x = -0.3, y = 750, label = "TREATMENT ASSIGNMENT", color = "black", alpha=0.5,
angle = 90) +
theme_bw() + scale_color_brewer(palette="Paired") +
ggtitle("Mean earnings per quarter for treated and non-treated individuals")
}
match_did_nn_graph(6, df) # Plot
match_did_nn_graph(6, df) # Plot
df %>% ggplot(aes(x = p, group = d)) +
geom_density() + facet_wrap(~d) +
theme_bw() + scale_color_brewer(palette="Paired") +
ggtitle("Distribution of p for treated (d = 1) and untreated (d = 0) individuals")
control_p = df %>% filter(d == 0) %>% select(p)
control_t = df %>% filter(d == 1) %>% select(p)
range_control = c(min(control_p), max(control_p))
range_treatment = c(min(control_t), max(control_t))
range_control
range_treatment
lower_bound_score = max(min(control_p), min(control_t))
upper_bound_score = min(max(control_p), max(control_t))
lower_bound_score
upper_bound_score
common_support_df = df %>% filter(between(p, lower_bound_score, upper_bound_score))
did_nn_cs_4 <- match_did_nn_estimator(4, common_support_df)
did_nn_cs_5 <- match_did_nn_estimator(5, common_support_df)
did_nn_cs_6 <- match_did_nn_estimator(6, common_support_df)
did_nn_cs_4
did_nn_cs_5
did_nn_cs_6
did_kernel_cs_4 <- match_did_kernel_estimator(4, common_support_df)
did_kernel_cs_5 <- match_did_kernel_estimator(5, common_support_df)
did_kernel_cs_6 <- match_did_kernel_estimator(6, common_support_df)
did_kernel_cs_4
did_kernel_cs_5
did_kernel_cs_6
did_nn_cs_4 <- match_did_nn_estimator(4, common_support_df)
did_nn_cs_5 <- match_did_nn_estimator(5, common_support_df)
did_nn_cs_6 <- match_did_nn_estimator(6, common_support_df)
did_nn_cs_4
did_nn_cs_5
did_nn_cs_6
did_kernel_cs_4 <- match_did_kernel_estimator(4, common_support_df)
did_kernel_cs_5 <- match_did_kernel_estimator(5, common_support_df)
did_kernel_cs_6 <- match_did_kernel_estimator(6, common_support_df)
did_kernel_cs_4 <- match_did_kernel_estimator(4, common_support_df)
did_kernel_cs_5 <- match_did_kernel_estimator(5, common_support_df)
did_kernel_cs_6 <- match_did_kernel_estimator(6, common_support_df)
match_did_kernel_estimator = function(timeframe, data) {
post_vec = 1:timeframe
pre_vec = -post_vec
valid_indexes_post = data %>% filter(qtr %in% post_vec) %>%
select(id) %>% unique()
valid_indexes_pre = data %>% filter(qtr %in% pre_vec) %>%
select(id) %>% unique()
valid_indexes = intersect(valid_indexes_post, valid_indexes_pre) %>% unlist()
df_itemd = data %>% filter(id %in% valid_indexes) %>%
filter(qtr>= -timeframe) %>% filter(qtr <= timeframe) %>%
mutate(post = ifelse(qtr > 0, "post", "pre")) %>%
group_by(post, id) %>%
mutate(mean = mean(earn)) %>% slice(1) %>%
ungroup() %>%
select(id, d, mean, p, post) %>%
pivot_wider(names_from = post, values_from = mean) %>%
mutate(diff_in_means = post-pre) %>%
select(-c(post, pre))
score_control = df_itemd[df_itemd$d == 0, ]   # i generate which is which to get the
score_treatment =  df_itemd[df_itemd$d == 1, ]  #
combinations = expand.grid(score_treatment$p, score_control$p)
h = 2.345*nrow(df_itemd)^(-1/5)*sd(df_itemd$p)
Kern_mat = matrix(epanechnikov((combinations[, 2] - combinations[, 1])/h), nrow = nrow(score_treatment))
W_mat = apply(Kern_mat, 2, function(i) i/sum(i))
alpha = colMeans(score_treatment$diff_in_means - W_mat %*% score_control$diff_in_means)
return(alpha)
}
epanechnikov = function(z) {0.75*(1-z^2)*as.numeric(abs(z)<1)}
match_did_kernel_estimator = function(timeframe, data) {
post_vec = 1:timeframe
pre_vec = -post_vec
valid_indexes_post = data %>% filter(qtr %in% post_vec) %>%
select(id) %>% unique()
valid_indexes_pre = data %>% filter(qtr %in% pre_vec) %>%
select(id) %>% unique()
valid_indexes = intersect(valid_indexes_post, valid_indexes_pre) %>% unlist()
df_itemd = data %>% filter(id %in% valid_indexes) %>%
filter(qtr>= -timeframe) %>% filter(qtr <= timeframe) %>%
mutate(post = ifelse(qtr > 0, "post", "pre")) %>%
group_by(post, id) %>%
mutate(mean = mean(earn)) %>% slice(1) %>%
ungroup() %>%
select(id, d, mean, p, post) %>%
pivot_wider(names_from = post, values_from = mean) %>%
mutate(diff_in_means = post-pre) %>%
select(-c(post, pre))
score_control = df_itemd[df_itemd$d == 0, ]   # i generate which is which to get the
score_treatment =  df_itemd[df_itemd$d == 1, ]  #
combinations = expand.grid(score_treatment$p, score_control$p)
h = 2.345*nrow(df_itemd)^(-1/5)*sd(df_itemd$p)
Kern_mat = matrix(epanechnikov((combinations[, 2] - combinations[, 1])/h), nrow = nrow(score_treatment))
W_mat = apply(Kern_mat, 2, function(i) i/sum(i))
alpha = colMeans(score_treatment$diff_in_means - W_mat %*% score_control$diff_in_means)
return(alpha)
}
did_kernel_4 <- match_did_kernel_estimator(4, df)
did_kernel_5 <- match_did_kernel_estimator(5, df)
did_kernel_6 <- match_did_kernel_estimator(6, df)
did_kernel_4
did_kernel_5
did_kernel_6
df %>% ggplot(aes(x = p, group = d)) +
geom_density() + facet_wrap(~d) +
theme_bw() + scale_color_brewer(palette="Paired") +
ggtitle("Distribution of p for treated (d = 1) and untreated (d = 0) individuals")
control_p = df %>% filter(d == 0) %>% select(p)
control_t = df %>% filter(d == 1) %>% select(p)
range_control = c(min(control_p), max(control_p))
range_treatment = c(min(control_t), max(control_t))
range_control
range_treatment
lower_bound_score = max(min(control_p), min(control_t))
upper_bound_score = min(max(control_p), max(control_t))
lower_bound_score
upper_bound_score
common_support_df = df %>% filter(between(p, lower_bound_score, upper_bound_score))
did_nn_cs_4 <- match_did_nn_estimator(4, common_support_df)
did_nn_cs_5 <- match_did_nn_estimator(5, common_support_df)
did_nn_cs_6 <- match_did_nn_estimator(6, common_support_df)
did_nn_cs_4
did_nn_cs_5
did_nn_cs_6
did_kernel_cs_4 <- match_did_kernel_estimator(4, common_support_df)
did_kernel_cs_5 <- match_did_kernel_estimator(5, common_support_df)
did_kernel_cs_6 <- match_did_kernel_estimator(6, common_support_df)
did_kernel_cs_4
did_kernel_cs_5
did_kernel_cs_6
match_did_nn_graph(6, common_support_df) # Plot
df2 = read_csv('enoe_q219-q122_married_female.csv')
match_did_nn_graph(6, common_support_df) # Plot
match_did_nn_graph(6, df) # Plot
match_did_nn_graph(6, df) # Plot
match_did_nn_graph = function(timeframe, data) {
post_vec = 1:timeframe        # Generate the array of necessary observations.
pre_vec = -post_vec
valid_indexes_post = data %>% filter(qtr %in% post_vec) %>%  # Check if this ID has a valid post
select(id) %>% unique()                                    # observation.
valid_indexes_pre = data %>% filter(qtr %in% pre_vec) %>%   # The same, but for before treatment.
select(id) %>% unique()
valid_indexes = intersect(valid_indexes_post, valid_indexes_pre) %>% unlist() # Get IDs with both.
df_itemd = data %>% filter(id %in% valid_indexes) %>%        # Get only correct IDs.
filter(qtr>= -timeframe) %>% filter(qtr <= timeframe) %>%  # Get only relevant obs from them.
mutate(post = ifelse(qtr > 0, "post", "pre"))
score_control = df_itemd[df_itemd$d == 0, ] # i generate which is which to get the
score_treatment =  df_itemd[df_itemd$d == 1, ]  # nearest neighbors using RANN
nn_indexes = nn2(score_control$p, score_treatment$p, k = 2)
df_nn = as.data.frame(nn_indexes$nn.idx)
df_with_match = tibble(score_treatment, id1 = score_control[df_nn$V1, ]$id,
id2 = score_control[df_nn$V2, ]$id) %>%
left_join(select(score_control, c('id', 'earn', 'qtr')), by = c("id1" = "id", "qtr")) %>%
left_join(select(score_control, c('id', 'earn', 'qtr')), by = c("id2" = "id", "qtr")) %>%
mutate(earn_control = earn.y + earn)
match_control = df_with_match %>% select(id, qtr, earn_control) %>%
mutate(d=0) %>% rename('earn' = earn_control)
graph_df = score_treatment %>% select(id, qtr, d, earn) %>% rbind(match_control) %>%
group_by(qtr, d) %>% summarise(mean = mean(earn, na.rm = T)) %>%
mutate(post = ifelse(qtr>0, 1, 0))
ggplot(graph_df, aes(x = qtr, y = mean, color = as.factor(d) )) + geom_line(linetype = 'dashed') +
geom_line(data = graph_df[graph_df$qtr <= -1, ], aes(x = qtr, y = mean, color =
as.factor(d)), size = 1.1) +
geom_line(data = graph_df[graph_df$qtr >= 1, ], aes(x = qtr, y = mean, color =
as.factor(d)), size = 1.1) +
labs(color = 'Treatment Status') +
geom_vline(xintercept = 0, linetype = 'dashed', alpha=0.5) +
annotate(geom = "text", x = -0.3, y = 750, label = "TREATMENT ASSIGNMENT", color = "black", alpha=0.5,
angle = 90) +
theme_bw() + scale_color_brewer(palette="Paired") +
ggtitle("Mean earnings per quarter for treated and non-treated individuals (MDID 2-NN Estimator)")
}
match_did_nn_graph(6, df) # Plot
df = read_csv("jtpa_ps2.csv")
match_did_nn_graph(6, df) # Plot
match_did_nn_graph = function(timeframe, data) {
post_vec = 1:timeframe        # Generate the array of necessary observations.
pre_vec = -post_vec
valid_indexes_post = data %>% filter(qtr %in% post_vec) %>%  # Check if this ID has a valid post
select(id) %>% unique()                                    # observation.
valid_indexes_pre = data %>% filter(qtr %in% pre_vec) %>%   # The same, but for before treatment.
select(id) %>% unique()
valid_indexes = intersect(valid_indexes_post, valid_indexes_pre) %>% unlist() # Get IDs with both.
df_itemd = data %>% filter(id %in% valid_indexes) %>%        # Get only correct IDs.
filter(qtr>= -timeframe) %>% filter(qtr <= timeframe) %>%  # Get only relevant obs from them.
mutate(post = ifelse(qtr > 0, "post", "pre"))
score_control = df_itemd[df_itemd$d == 0, ] # i generate which is which to get the
score_treatment =  df_itemd[df_itemd$d == 1, ]  # nearest neighbors using RANN
nn_indexes = nn2(score_control$p, score_treatment$p, k = 2)
df_nn = as.data.frame(nn_indexes$nn.idx)
df_with_match = tibble(score_treatment, id1 = score_control[df_nn$V1, ]$id,
id2 = score_control[df_nn$V2, ]$id) %>%
left_join(select(score_control, c('id', 'earn', 'qtr')), by = c("id1" = "id", "qtr")) %>%
left_join(select(score_control, c('id', 'earn', 'qtr')), by = c("id2" = "id", "qtr")) %>%
mutate(earn_control = earn.y + earn)
match_control = df_with_match %>% select(id, qtr, earn_control) %>%
mutate(d=0) %>% rename('earn' = earn_control)
graph_df = score_treatment %>% select(id, qtr, d, earn) %>% rbind(match_control) %>%
group_by(qtr, d) %>% summarise(mean = mean(earn, na.rm = T)) %>%
mutate(post = ifelse(qtr>0, 1, 0))
ggplot(graph_df, aes(x = qtr, y = mean, color = as.factor(d) )) + geom_line(linetype = 'dashed') +
geom_line(data = graph_df[graph_df$qtr <= -1, ], aes(x = qtr, y = mean, color =
as.factor(d)), size = 1.1) +
geom_line(data = graph_df[graph_df$qtr >= 1, ], aes(x = qtr, y = mean, color =
as.factor(d)), size = 1.1) +
labs(color = 'Treatment Status') +
geom_vline(xintercept = 0, linetype = 'dashed', alpha=0.5) +
annotate(geom = "text", x = -0.3, y = 750, label = "TREATMENT ASSIGNMENT", color = "black", alpha=0.5,
angle = 90) +
theme_bw() + scale_color_brewer(palette="Paired") +
ggtitle("Mean earnings per quarter for treated and non-treated individuals (MDID 2-NN Estimator)")
}
match_did_nn_graph(6, df) # Plot
match_did_nn_graph(6, df) # Plot
# Plotting a similar plot to that of item (c), but for the 2-NN estimator with common support.
match_did_nn_graph(6, common_support_df) # Plot
